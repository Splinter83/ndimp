// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "Command.hxx"

namespace cs
{
  // TestType
  // 

  const TestType::TestNumber_type& TestType::
  TestNumber () const
  {
    return this->TestNumber_.get ();
  }

  TestType::TestNumber_type& TestType::
  TestNumber ()
  {
    return this->TestNumber_.get ();
  }

  void TestType::
  TestNumber (const TestNumber_type& x)
  {
    this->TestNumber_.set (x);
  }

  const TestType::TestString_optional& TestType::
  TestString () const
  {
    return this->TestString_;
  }

  TestType::TestString_optional& TestType::
  TestString ()
  {
    return this->TestString_;
  }

  void TestType::
  TestString (const TestString_type& x)
  {
    this->TestString_.set (x);
  }

  void TestType::
  TestString (const TestString_optional& x)
  {
    this->TestString_ = x;
  }

  void TestType::
  TestString (::std::auto_ptr< TestString_type > x)
  {
    this->TestString_.set (x);
  }

  const TestType::Description_optional& TestType::
  Description () const
  {
    return this->Description_;
  }

  TestType::Description_optional& TestType::
  Description ()
  {
    return this->Description_;
  }

  void TestType::
  Description (const Description_type& x)
  {
    this->Description_.set (x);
  }

  void TestType::
  Description (const Description_optional& x)
  {
    this->Description_ = x;
  }

  void TestType::
  Description (::std::auto_ptr< Description_type > x)
  {
    this->Description_.set (x);
  }

  const TestType::StepNumber_optional& TestType::
  StepNumber () const
  {
    return this->StepNumber_;
  }

  TestType::StepNumber_optional& TestType::
  StepNumber ()
  {
    return this->StepNumber_;
  }

  void TestType::
  StepNumber (const StepNumber_type& x)
  {
    this->StepNumber_.set (x);
  }

  void TestType::
  StepNumber (const StepNumber_optional& x)
  {
    this->StepNumber_ = x;
  }

  TestType::StepNumber_type TestType::
  StepNumber_default_value ()
  {
    return StepNumber_type (1);
  }

  const TestType::TestEnum_type& TestType::
  TestEnum () const
  {
    return this->TestEnum_.get ();
  }

  TestType::TestEnum_type& TestType::
  TestEnum ()
  {
    return this->TestEnum_.get ();
  }

  void TestType::
  TestEnum (const TestEnum_type& x)
  {
    this->TestEnum_.set (x);
  }

  void TestType::
  TestEnum (::std::auto_ptr< TestEnum_type > x)
  {
    this->TestEnum_.set (x);
  }

  const TestType::TerminalNumber_optional& TestType::
  TerminalNumber () const
  {
    return this->TerminalNumber_;
  }

  TestType::TerminalNumber_optional& TestType::
  TerminalNumber ()
  {
    return this->TerminalNumber_;
  }

  void TestType::
  TerminalNumber (const TerminalNumber_type& x)
  {
    this->TerminalNumber_.set (x);
  }

  void TestType::
  TerminalNumber (const TerminalNumber_optional& x)
  {
    this->TerminalNumber_ = x;
  }

  const TestType::Channel_optional& TestType::
  Channel () const
  {
    return this->Channel_;
  }

  TestType::Channel_optional& TestType::
  Channel ()
  {
    return this->Channel_;
  }

  void TestType::
  Channel (const Channel_type& x)
  {
    this->Channel_.set (x);
  }

  void TestType::
  Channel (const Channel_optional& x)
  {
    this->Channel_ = x;
  }

  void TestType::
  Channel (::std::auto_ptr< Channel_type > x)
  {
    this->Channel_.set (x);
  }

  const TestType::RCI_optional& TestType::
  RCI () const
  {
    return this->RCI_;
  }

  TestType::RCI_optional& TestType::
  RCI ()
  {
    return this->RCI_;
  }

  void TestType::
  RCI (const RCI_type& x)
  {
    this->RCI_.set (x);
  }

  void TestType::
  RCI (const RCI_optional& x)
  {
    this->RCI_ = x;
  }


  // BoardConfigurationType
  // 

  const BoardConfigurationType::BaseAddress_type& BoardConfigurationType::
  BaseAddress () const
  {
    return this->BaseAddress_.get ();
  }

  BoardConfigurationType::BaseAddress_type& BoardConfigurationType::
  BaseAddress ()
  {
    return this->BaseAddress_.get ();
  }

  void BoardConfigurationType::
  BaseAddress (const BaseAddress_type& x)
  {
    this->BaseAddress_.set (x);
  }

  void BoardConfigurationType::
  BaseAddress (::std::auto_ptr< BaseAddress_type > x)
  {
    this->BaseAddress_.set (x);
  }

  const BoardConfigurationType::RAMsize_type& BoardConfigurationType::
  RAMsize () const
  {
    return this->RAMsize_.get ();
  }

  BoardConfigurationType::RAMsize_type& BoardConfigurationType::
  RAMsize ()
  {
    return this->RAMsize_.get ();
  }

  void BoardConfigurationType::
  RAMsize (const RAMsize_type& x)
  {
    this->RAMsize_.set (x);
  }

  void BoardConfigurationType::
  RAMsize (::std::auto_ptr< RAMsize_type > x)
  {
    this->RAMsize_.set (x);
  }

  const BoardConfigurationType::Type_type& BoardConfigurationType::
  Type () const
  {
    return this->Type_.get ();
  }

  BoardConfigurationType::Type_type& BoardConfigurationType::
  Type ()
  {
    return this->Type_.get ();
  }

  void BoardConfigurationType::
  Type (const Type_type& x)
  {
    this->Type_.set (x);
  }

  void BoardConfigurationType::
  Type (::std::auto_ptr< Type_type > x)
  {
    this->Type_.set (x);
  }

  const BoardConfigurationType::Arbitered_IO_type& BoardConfigurationType::
  Arbitered_IO () const
  {
    return this->Arbitered_IO_.get ();
  }

  BoardConfigurationType::Arbitered_IO_type& BoardConfigurationType::
  Arbitered_IO ()
  {
    return this->Arbitered_IO_.get ();
  }

  void BoardConfigurationType::
  Arbitered_IO (const Arbitered_IO_type& x)
  {
    this->Arbitered_IO_.set (x);
  }

  void BoardConfigurationType::
  Arbitered_IO (::std::auto_ptr< Arbitered_IO_type > x)
  {
    this->Arbitered_IO_.set (x);
  }

  const BoardConfigurationType::Direct_IO_type& BoardConfigurationType::
  Direct_IO () const
  {
    return this->Direct_IO_.get ();
  }

  BoardConfigurationType::Direct_IO_type& BoardConfigurationType::
  Direct_IO ()
  {
    return this->Direct_IO_.get ();
  }

  void BoardConfigurationType::
  Direct_IO (const Direct_IO_type& x)
  {
    this->Direct_IO_.set (x);
  }

  void BoardConfigurationType::
  Direct_IO (::std::auto_ptr< Direct_IO_type > x)
  {
    this->Direct_IO_.set (x);
  }

  const BoardConfigurationType::Restart_HS_type& BoardConfigurationType::
  Restart_HS () const
  {
    return this->Restart_HS_.get ();
  }

  BoardConfigurationType::Restart_HS_type& BoardConfigurationType::
  Restart_HS ()
  {
    return this->Restart_HS_.get ();
  }

  void BoardConfigurationType::
  Restart_HS (const Restart_HS_type& x)
  {
    this->Restart_HS_.set (x);
  }

  void BoardConfigurationType::
  Restart_HS (::std::auto_ptr< Restart_HS_type > x)
  {
    this->Restart_HS_.set (x);
  }

  const BoardConfigurationType::InterfaceName_type& BoardConfigurationType::
  InterfaceName () const
  {
    return this->InterfaceName_.get ();
  }

  BoardConfigurationType::InterfaceName_type& BoardConfigurationType::
  InterfaceName ()
  {
    return this->InterfaceName_.get ();
  }

  void BoardConfigurationType::
  InterfaceName (const InterfaceName_type& x)
  {
    this->InterfaceName_.set (x);
  }

  void BoardConfigurationType::
  InterfaceName (::std::auto_ptr< InterfaceName_type > x)
  {
    this->InterfaceName_.set (x);
  }

  const BoardConfigurationType::RTAddress_optional& BoardConfigurationType::
  RTAddress () const
  {
    return this->RTAddress_;
  }

  BoardConfigurationType::RTAddress_optional& BoardConfigurationType::
  RTAddress ()
  {
    return this->RTAddress_;
  }

  void BoardConfigurationType::
  RTAddress (const RTAddress_type& x)
  {
    this->RTAddress_.set (x);
  }

  void BoardConfigurationType::
  RTAddress (const RTAddress_optional& x)
  {
    this->RTAddress_ = x;
  }

  const BoardConfigurationType::BITHistory_Addr_type& BoardConfigurationType::
  BITHistory_Addr () const
  {
    return this->BITHistory_Addr_.get ();
  }

  BoardConfigurationType::BITHistory_Addr_type& BoardConfigurationType::
  BITHistory_Addr ()
  {
    return this->BITHistory_Addr_.get ();
  }

  void BoardConfigurationType::
  BITHistory_Addr (const BITHistory_Addr_type& x)
  {
    this->BITHistory_Addr_.set (x);
  }

  void BoardConfigurationType::
  BITHistory_Addr (::std::auto_ptr< BITHistory_Addr_type > x)
  {
    this->BITHistory_Addr_.set (x);
  }

  const BoardConfigurationType::BITHistory_Size_type& BoardConfigurationType::
  BITHistory_Size () const
  {
    return this->BITHistory_Size_.get ();
  }

  BoardConfigurationType::BITHistory_Size_type& BoardConfigurationType::
  BITHistory_Size ()
  {
    return this->BITHistory_Size_.get ();
  }

  void BoardConfigurationType::
  BITHistory_Size (const BITHistory_Size_type& x)
  {
    this->BITHistory_Size_.set (x);
  }

  void BoardConfigurationType::
  BITHistory_Size (::std::auto_ptr< BITHistory_Size_type > x)
  {
    this->BITHistory_Size_.set (x);
  }


  // CommandType
  // 

  const CommandType::Read_optional& CommandType::
  Read () const
  {
    return this->Read_;
  }

  CommandType::Read_optional& CommandType::
  Read ()
  {
    return this->Read_;
  }

  void CommandType::
  Read (const Read_type& x)
  {
    this->Read_.set (x);
  }

  void CommandType::
  Read (const Read_optional& x)
  {
    this->Read_ = x;
  }

  void CommandType::
  Read (::std::auto_ptr< Read_type > x)
  {
    this->Read_.set (x);
  }

  const CommandType::Write_optional& CommandType::
  Write () const
  {
    return this->Write_;
  }

  CommandType::Write_optional& CommandType::
  Write ()
  {
    return this->Write_;
  }

  void CommandType::
  Write (const Write_type& x)
  {
    this->Write_.set (x);
  }

  void CommandType::
  Write (const Write_optional& x)
  {
    this->Write_ = x;
  }

  void CommandType::
  Write (::std::auto_ptr< Write_type > x)
  {
    this->Write_.set (x);
  }

  const CommandType::Test_optional& CommandType::
  Test () const
  {
    return this->Test_;
  }

  CommandType::Test_optional& CommandType::
  Test ()
  {
    return this->Test_;
  }

  void CommandType::
  Test (const Test_type& x)
  {
    this->Test_.set (x);
  }

  void CommandType::
  Test (const Test_optional& x)
  {
    this->Test_ = x;
  }

  void CommandType::
  Test (::std::auto_ptr< Test_type > x)
  {
    this->Test_.set (x);
  }

  const CommandType::Config_optional& CommandType::
  Config () const
  {
    return this->Config_;
  }

  CommandType::Config_optional& CommandType::
  Config ()
  {
    return this->Config_;
  }

  void CommandType::
  Config (const Config_type& x)
  {
    this->Config_.set (x);
  }

  void CommandType::
  Config (const Config_optional& x)
  {
    this->Config_ = x;
  }

  void CommandType::
  Config (::std::auto_ptr< Config_type > x)
  {
    this->Config_.set (x);
  }

  const CommandType::SGA_optional& CommandType::
  SGA () const
  {
    return this->SGA_;
  }

  CommandType::SGA_optional& CommandType::
  SGA ()
  {
    return this->SGA_;
  }

  void CommandType::
  SGA (const SGA_type& x)
  {
    this->SGA_.set (x);
  }

  void CommandType::
  SGA (const SGA_optional& x)
  {
    this->SGA_ = x;
  }

  void CommandType::
  SGA (::std::auto_ptr< SGA_type > x)
  {
    this->SGA_.set (x);
  }

  const CommandType::id_type& CommandType::
  id () const
  {
    return this->id_.get ();
  }

  CommandType::id_type& CommandType::
  id ()
  {
    return this->id_.get ();
  }

  void CommandType::
  id (const id_type& x)
  {
    this->id_.set (x);
  }

  void CommandType::
  id (::std::auto_ptr< id_type > x)
  {
    this->id_.set (x);
  }

  const CommandType::Board_type& CommandType::
  Board () const
  {
    return this->Board_.get ();
  }

  CommandType::Board_type& CommandType::
  Board ()
  {
    return this->Board_.get ();
  }

  void CommandType::
  Board (const Board_type& x)
  {
    this->Board_.set (x);
  }

  void CommandType::
  Board (::std::auto_ptr< Board_type > x)
  {
    this->Board_.set (x);
  }


  // CommandList
  // 

  const CommandList::Command_sequence& CommandList::
  Command () const
  {
    return this->Command_;
  }

  CommandList::Command_sequence& CommandList::
  Command ()
  {
    return this->Command_;
  }

  void CommandList::
  Command (const Command_sequence& s)
  {
    this->Command_ = s;
  }

  const CommandList::size_type& CommandList::
  size () const
  {
    return this->size_.get ();
  }

  CommandList::size_type& CommandList::
  size ()
  {
    return this->size_.get ();
  }

  void CommandList::
  size (const size_type& x)
  {
    this->size_.set (x);
  }

  void CommandList::
  size (::std::auto_ptr< size_type > x)
  {
    this->size_.set (x);
  }


  // TestEnum
  // 

  TestEnum::
  TestEnum (value v)
  : ::xml_schema::string (_xsd_TestEnum_literals_[v])
  {
  }

  TestEnum::
  TestEnum (const char* v)
  : ::xml_schema::string (v)
  {
  }

  TestEnum::
  TestEnum (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  TestEnum::
  TestEnum (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  TestEnum::
  TestEnum (const TestEnum& v,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  TestEnum& TestEnum::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_TestEnum_literals_[v]);

    return *this;
  }


  // Channel
  // 

  Channel::
  Channel (value v)
  : ::xml_schema::string (_xsd_Channel_literals_[v])
  {
  }

  Channel::
  Channel (const char* v)
  : ::xml_schema::string (v)
  {
  }

  Channel::
  Channel (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  Channel::
  Channel (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  Channel::
  Channel (const Channel& v,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  Channel& Channel::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_Channel_literals_[v]);

    return *this;
  }


  // Type
  // 

  Type::
  Type (value v)
  : ::xml_schema::string (_xsd_Type_literals_[v])
  {
  }

  Type::
  Type (const char* v)
  : ::xml_schema::string (v)
  {
  }

  Type::
  Type (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  Type::
  Type (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  Type::
  Type (const Type& v,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  Type& Type::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_Type_literals_[v]);

    return *this;
  }


  // InterfaceName
  // 

  InterfaceName::
  InterfaceName (value v)
  : ::xml_schema::string (_xsd_InterfaceName_literals_[v])
  {
  }

  InterfaceName::
  InterfaceName (const char* v)
  : ::xml_schema::string (v)
  {
  }

  InterfaceName::
  InterfaceName (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  InterfaceName::
  InterfaceName (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  InterfaceName::
  InterfaceName (const InterfaceName& v,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  InterfaceName& InterfaceName::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_InterfaceName_literals_[v]);

    return *this;
  }


  // Read
  // 

  const Read::Address_type& Read::
  Address () const
  {
    return this->Address_.get ();
  }

  Read::Address_type& Read::
  Address ()
  {
    return this->Address_.get ();
  }

  void Read::
  Address (const Address_type& x)
  {
    this->Address_.set (x);
  }

  void Read::
  Address (::std::auto_ptr< Address_type > x)
  {
    this->Address_.set (x);
  }

  const Read::Alignment_optional& Read::
  Alignment () const
  {
    return this->Alignment_;
  }

  Read::Alignment_optional& Read::
  Alignment ()
  {
    return this->Alignment_;
  }

  void Read::
  Alignment (const Alignment_type& x)
  {
    this->Alignment_.set (x);
  }

  void Read::
  Alignment (const Alignment_optional& x)
  {
    this->Alignment_ = x;
  }

  void Read::
  Alignment (::std::auto_ptr< Alignment_type > x)
  {
    this->Alignment_.set (x);
  }


  // Write
  // 

  const Write::Address_type& Write::
  Address () const
  {
    return this->Address_.get ();
  }

  Write::Address_type& Write::
  Address ()
  {
    return this->Address_.get ();
  }

  void Write::
  Address (const Address_type& x)
  {
    this->Address_.set (x);
  }

  void Write::
  Address (::std::auto_ptr< Address_type > x)
  {
    this->Address_.set (x);
  }

  const Write::Data_type& Write::
  Data () const
  {
    return this->Data_.get ();
  }

  Write::Data_type& Write::
  Data ()
  {
    return this->Data_.get ();
  }

  void Write::
  Data (const Data_type& x)
  {
    this->Data_.set (x);
  }

  void Write::
  Data (::std::auto_ptr< Data_type > x)
  {
    this->Data_.set (x);
  }

  const Write::Alignment_optional& Write::
  Alignment () const
  {
    return this->Alignment_;
  }

  Write::Alignment_optional& Write::
  Alignment ()
  {
    return this->Alignment_;
  }

  void Write::
  Alignment (const Alignment_type& x)
  {
    this->Alignment_.set (x);
  }

  void Write::
  Alignment (const Alignment_optional& x)
  {
    this->Alignment_ = x;
  }

  void Write::
  Alignment (::std::auto_ptr< Alignment_type > x)
  {
    this->Alignment_.set (x);
  }


  // SGA
  // 

  const SGA::Value_type& SGA::
  Value () const
  {
    return this->Value_.get ();
  }

  SGA::Value_type& SGA::
  Value ()
  {
    return this->Value_.get ();
  }

  void SGA::
  Value (const Value_type& x)
  {
    this->Value_.set (x);
  }

  void SGA::
  Value (::std::auto_ptr< Value_type > x)
  {
    this->Value_.set (x);
  }


  // Board
  // 

  Board::
  Board (value v)
  : ::xml_schema::string (_xsd_Board_literals_[v])
  {
  }

  Board::
  Board (const char* v)
  : ::xml_schema::string (v)
  {
  }

  Board::
  Board (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  Board::
  Board (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  Board::
  Board (const Board& v,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  Board& Board::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_Board_literals_[v]);

    return *this;
  }


  // Command
  // 


  // size
  // 


  // Alignment
  // 

  Alignment::
  Alignment (value v)
  : ::xml_schema::string (_xsd_Alignment_literals_[v])
  {
  }

  Alignment::
  Alignment (const char* v)
  : ::xml_schema::string (v)
  {
  }

  Alignment::
  Alignment (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  Alignment::
  Alignment (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  Alignment::
  Alignment (const Alignment& v,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  Alignment& Alignment::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_Alignment_literals_[v]);

    return *this;
  }


  // Alignment1
  // 

  Alignment1::
  Alignment1 (value v)
  : ::xml_schema::string (_xsd_Alignment1_literals_[v])
  {
  }

  Alignment1::
  Alignment1 (const char* v)
  : ::xml_schema::string (v)
  {
  }

  Alignment1::
  Alignment1 (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  Alignment1::
  Alignment1 (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  Alignment1::
  Alignment1 (const Alignment1& v,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  Alignment1& Alignment1::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_Alignment1_literals_[v]);

    return *this;
  }


  // Value
  // 

  Value::
  Value (value v)
  : ::xml_schema::string (_xsd_Value_literals_[v])
  {
  }

  Value::
  Value (const char* v)
  : ::xml_schema::string (v)
  {
  }

  Value::
  Value (const ::std::string& v)
  : ::xml_schema::string (v)
  {
  }

  Value::
  Value (const ::xml_schema::string& v)
  : ::xml_schema::string (v)
  {
  }

  Value::
  Value (const Value& v,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (v, f, c)
  {
  }

  Value& Value::
  operator= (value v)
  {
    static_cast< ::xml_schema::string& > (*this) = 
    ::xml_schema::string (_xsd_Value_literals_[v]);

    return *this;
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

namespace cs
{
  // TestType
  //

  TestType::
  TestType (const TestNumber_type& TestNumber,
            const TestEnum_type& TestEnum)
  : ::xml_schema::type (),
    TestNumber_ (TestNumber, ::xml_schema::flags (), this),
    TestString_ (::xml_schema::flags (), this),
    Description_ (::xml_schema::flags (), this),
    StepNumber_ (::xml_schema::flags (), this),
    TestEnum_ (TestEnum, ::xml_schema::flags (), this),
    TerminalNumber_ (::xml_schema::flags (), this),
    Channel_ (::xml_schema::flags (), this),
    RCI_ (::xml_schema::flags (), this)
  {
  }

  TestType::
  TestType (const TestType& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    TestNumber_ (x.TestNumber_, f, this),
    TestString_ (x.TestString_, f, this),
    Description_ (x.Description_, f, this),
    StepNumber_ (x.StepNumber_, f, this),
    TestEnum_ (x.TestEnum_, f, this),
    TerminalNumber_ (x.TerminalNumber_, f, this),
    Channel_ (x.Channel_, f, this),
    RCI_ (x.RCI_, f, this)
  {
  }

  TestType::
  TestType (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    TestNumber_ (f, this),
    TestString_ (f, this),
    Description_ (f, this),
    StepNumber_ (f, this),
    TestEnum_ (f, this),
    TerminalNumber_ (f, this),
    Channel_ (f, this),
    RCI_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void TestType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // TestNumber
      //
      if (n.name () == "TestNumber" && n.namespace_ ().empty ())
      {
        if (!TestNumber_.present ())
        {
          this->TestNumber_.set (TestNumber_traits::create (i, f, this));
          continue;
        }
      }

      // TestString
      //
      if (n.name () == "TestString" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< TestString_type > r (
          TestString_traits::create (i, f, this));

        if (!this->TestString_)
        {
          this->TestString_.set (r);
          continue;
        }
      }

      // Description
      //
      if (n.name () == "Description" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Description_type > r (
          Description_traits::create (i, f, this));

        if (!this->Description_)
        {
          this->Description_.set (r);
          continue;
        }
      }

      // StepNumber
      //
      if (n.name () == "StepNumber" && n.namespace_ ().empty ())
      {
        if (!this->StepNumber_)
        {
          this->StepNumber_.set (StepNumber_traits::create (i, f, this));
          continue;
        }
      }

      // TestEnum
      //
      if (n.name () == "TestEnum" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< TestEnum_type > r (
          TestEnum_traits::create (i, f, this));

        if (!TestEnum_.present ())
        {
          this->TestEnum_.set (r);
          continue;
        }
      }

      // TerminalNumber
      //
      if (n.name () == "TerminalNumber" && n.namespace_ ().empty ())
      {
        if (!this->TerminalNumber_)
        {
          this->TerminalNumber_.set (TerminalNumber_traits::create (i, f, this));
          continue;
        }
      }

      // Channel
      //
      if (n.name () == "Channel" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Channel_type > r (
          Channel_traits::create (i, f, this));

        if (!this->Channel_)
        {
          this->Channel_.set (r);
          continue;
        }
      }

      // RCI
      //
      if (n.name () == "RCI" && n.namespace_ ().empty ())
      {
        if (!this->RCI_)
        {
          this->RCI_.set (RCI_traits::create (i, f, this));
          continue;
        }
      }

      break;
    }

    if (!TestNumber_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "TestNumber",
        "");
    }

    if (!TestEnum_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "TestEnum",
        "");
    }
  }

  TestType* TestType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class TestType (*this, f, c);
  }

  TestType::
  ~TestType ()
  {
  }

  // BoardConfigurationType
  //

  BoardConfigurationType::
  BoardConfigurationType (const BaseAddress_type& BaseAddress,
                          const RAMsize_type& RAMsize,
                          const Type_type& Type,
                          const Arbitered_IO_type& Arbitered_IO,
                          const Direct_IO_type& Direct_IO,
                          const Restart_HS_type& Restart_HS,
                          const InterfaceName_type& InterfaceName,
                          const BITHistory_Addr_type& BITHistory_Addr,
                          const BITHistory_Size_type& BITHistory_Size)
  : ::xml_schema::type (),
    BaseAddress_ (BaseAddress, ::xml_schema::flags (), this),
    RAMsize_ (RAMsize, ::xml_schema::flags (), this),
    Type_ (Type, ::xml_schema::flags (), this),
    Arbitered_IO_ (Arbitered_IO, ::xml_schema::flags (), this),
    Direct_IO_ (Direct_IO, ::xml_schema::flags (), this),
    Restart_HS_ (Restart_HS, ::xml_schema::flags (), this),
    InterfaceName_ (InterfaceName, ::xml_schema::flags (), this),
    RTAddress_ (::xml_schema::flags (), this),
    BITHistory_Addr_ (BITHistory_Addr, ::xml_schema::flags (), this),
    BITHistory_Size_ (BITHistory_Size, ::xml_schema::flags (), this)
  {
  }

  BoardConfigurationType::
  BoardConfigurationType (const BoardConfigurationType& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    BaseAddress_ (x.BaseAddress_, f, this),
    RAMsize_ (x.RAMsize_, f, this),
    Type_ (x.Type_, f, this),
    Arbitered_IO_ (x.Arbitered_IO_, f, this),
    Direct_IO_ (x.Direct_IO_, f, this),
    Restart_HS_ (x.Restart_HS_, f, this),
    InterfaceName_ (x.InterfaceName_, f, this),
    RTAddress_ (x.RTAddress_, f, this),
    BITHistory_Addr_ (x.BITHistory_Addr_, f, this),
    BITHistory_Size_ (x.BITHistory_Size_, f, this)
  {
  }

  BoardConfigurationType::
  BoardConfigurationType (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    BaseAddress_ (f, this),
    RAMsize_ (f, this),
    Type_ (f, this),
    Arbitered_IO_ (f, this),
    Direct_IO_ (f, this),
    Restart_HS_ (f, this),
    InterfaceName_ (f, this),
    RTAddress_ (f, this),
    BITHistory_Addr_ (f, this),
    BITHistory_Size_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void BoardConfigurationType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // BaseAddress
      //
      if (n.name () == "BaseAddress" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< BaseAddress_type > r (
          BaseAddress_traits::create (i, f, this));

        if (!BaseAddress_.present ())
        {
          this->BaseAddress_.set (r);
          continue;
        }
      }

      // RAMsize
      //
      if (n.name () == "RAMsize" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< RAMsize_type > r (
          RAMsize_traits::create (i, f, this));

        if (!RAMsize_.present ())
        {
          this->RAMsize_.set (r);
          continue;
        }
      }

      // Type
      //
      if (n.name () == "Type" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Type_type > r (
          Type_traits::create (i, f, this));

        if (!Type_.present ())
        {
          this->Type_.set (r);
          continue;
        }
      }

      // Arbitered_IO
      //
      if (n.name () == "Arbitered_IO" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Arbitered_IO_type > r (
          Arbitered_IO_traits::create (i, f, this));

        if (!Arbitered_IO_.present ())
        {
          this->Arbitered_IO_.set (r);
          continue;
        }
      }

      // Direct_IO
      //
      if (n.name () == "Direct_IO" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Direct_IO_type > r (
          Direct_IO_traits::create (i, f, this));

        if (!Direct_IO_.present ())
        {
          this->Direct_IO_.set (r);
          continue;
        }
      }

      // Restart_HS
      //
      if (n.name () == "Restart_HS" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Restart_HS_type > r (
          Restart_HS_traits::create (i, f, this));

        if (!Restart_HS_.present ())
        {
          this->Restart_HS_.set (r);
          continue;
        }
      }

      // InterfaceName
      //
      if (n.name () == "InterfaceName" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< InterfaceName_type > r (
          InterfaceName_traits::create (i, f, this));

        if (!InterfaceName_.present ())
        {
          this->InterfaceName_.set (r);
          continue;
        }
      }

      // RTAddress
      //
      if (n.name () == "RTAddress" && n.namespace_ ().empty ())
      {
        if (!this->RTAddress_)
        {
          this->RTAddress_.set (RTAddress_traits::create (i, f, this));
          continue;
        }
      }

      // BITHistory_Addr
      //
      if (n.name () == "BITHistory_Addr" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< BITHistory_Addr_type > r (
          BITHistory_Addr_traits::create (i, f, this));

        if (!BITHistory_Addr_.present ())
        {
          this->BITHistory_Addr_.set (r);
          continue;
        }
      }

      // BITHistory_Size
      //
      if (n.name () == "BITHistory_Size" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< BITHistory_Size_type > r (
          BITHistory_Size_traits::create (i, f, this));

        if (!BITHistory_Size_.present ())
        {
          this->BITHistory_Size_.set (r);
          continue;
        }
      }

      break;
    }

    if (!BaseAddress_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "BaseAddress",
        "");
    }

    if (!RAMsize_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "RAMsize",
        "");
    }

    if (!Type_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Type",
        "");
    }

    if (!Arbitered_IO_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Arbitered_IO",
        "");
    }

    if (!Direct_IO_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Direct_IO",
        "");
    }

    if (!Restart_HS_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "Restart_HS",
        "");
    }

    if (!InterfaceName_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "InterfaceName",
        "");
    }

    if (!BITHistory_Addr_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "BITHistory_Addr",
        "");
    }

    if (!BITHistory_Size_.present ())
    {
      throw ::xsd::cxx::tree::expected_element< char > (
        "BITHistory_Size",
        "");
    }
  }

  BoardConfigurationType* BoardConfigurationType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class BoardConfigurationType (*this, f, c);
  }

  BoardConfigurationType::
  ~BoardConfigurationType ()
  {
  }

  // CommandType
  //

  CommandType::
  CommandType (const id_type& id,
               const Board_type& Board)
  : ::xml_schema::type (),
    Read_ (::xml_schema::flags (), this),
    Write_ (::xml_schema::flags (), this),
    Test_ (::xml_schema::flags (), this),
    Config_ (::xml_schema::flags (), this),
    SGA_ (::xml_schema::flags (), this),
    id_ (id, ::xml_schema::flags (), this),
    Board_ (Board, ::xml_schema::flags (), this)
  {
  }

  CommandType::
  CommandType (const CommandType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Read_ (x.Read_, f, this),
    Write_ (x.Write_, f, this),
    Test_ (x.Test_, f, this),
    Config_ (x.Config_, f, this),
    SGA_ (x.SGA_, f, this),
    id_ (x.id_, f, this),
    Board_ (x.Board_, f, this)
  {
  }

  CommandType::
  CommandType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Read_ (f, this),
    Write_ (f, this),
    Test_ (f, this),
    Config_ (f, this),
    SGA_ (f, this),
    id_ (f, this),
    Board_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void CommandType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Read
      //
      if (n.name () == "Read" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Read_type > r (
          Read_traits::create (i, f, this));

        if (!this->Read_)
        {
          this->Read_.set (r);
          continue;
        }
      }

      // Write
      //
      if (n.name () == "Write" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Write_type > r (
          Write_traits::create (i, f, this));

        if (!this->Write_)
        {
          this->Write_.set (r);
          continue;
        }
      }

      // Test
      //
      if (n.name () == "Test" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Test_type > r (
          Test_traits::create (i, f, this));

        if (!this->Test_)
        {
          this->Test_.set (r);
          continue;
        }
      }

      // Config
      //
      if (n.name () == "Config" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Config_type > r (
          Config_traits::create (i, f, this));

        if (!this->Config_)
        {
          this->Config_.set (r);
          continue;
        }
      }

      // SGA
      //
      if (n.name () == "SGA" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< SGA_type > r (
          SGA_traits::create (i, f, this));

        if (!this->SGA_)
        {
          this->SGA_.set (r);
          continue;
        }
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "id" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< id_type > r (
          id_traits::create (i, f, this));

        this->id_.set (r);
        continue;
      }

      if (n.name () == "Board" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Board_type > r (
          Board_traits::create (i, f, this));

        this->Board_.set (r);
        continue;
      }
    }

    if (!id_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "id",
        "");
    }

    if (!Board_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Board",
        "");
    }
  }

  CommandType* CommandType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CommandType (*this, f, c);
  }

  CommandType::
  ~CommandType ()
  {
  }

  // CommandList
  //

  CommandList::
  CommandList (const size_type& size)
  : ::xml_schema::type (),
    Command_ (::xml_schema::flags (), this),
    size_ (size, ::xml_schema::flags (), this)
  {
  }

  CommandList::
  CommandList (const CommandList& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Command_ (x.Command_, f, this),
    size_ (x.size_, f, this)
  {
  }

  CommandList::
  CommandList (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Command_ (f, this),
    size_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, true);
      this->parse (p, f);
    }
  }

  void CommandList::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // Command
      //
      if (n.name () == "Command" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Command_type > r (
          Command_traits::create (i, f, this));

        this->Command_.push_back (r);
        continue;
      }

      break;
    }

    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "size" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< size_type > r (
          size_traits::create (i, f, this));

        this->size_.set (r);
        continue;
      }
    }

    if (!size_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "size",
        "");
    }
  }

  CommandList* CommandList::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class CommandList (*this, f, c);
  }

  CommandList::
  ~CommandList ()
  {
  }

  // TestEnum
  //

  TestEnum::
  TestEnum (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_TestEnum_convert ();
  }

  TestEnum::
  TestEnum (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_TestEnum_convert ();
  }

  TestEnum::
  TestEnum (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_TestEnum_convert ();
  }

  TestEnum* TestEnum::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class TestEnum (*this, f, c);
  }

  TestEnum::value TestEnum::
  _xsd_TestEnum_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_TestEnum_literals_);
    const value* i (::std::lower_bound (
                      _xsd_TestEnum_indexes_,
                      _xsd_TestEnum_indexes_ + 14,
                      *this,
                      c));

    if (i == _xsd_TestEnum_indexes_ + 14 || _xsd_TestEnum_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const TestEnum::
  _xsd_TestEnum_literals_[14] =
  {
    "SIMP1_AVIONIC_3910",
    "SIMP1_BSD_EDDL",
    "SIMP1_MDP_EDDL",
    "SIMP1_CSMU_EDDL",
    "SIMP2_ATTACK_3910",
    "SIMP2_EMU1_EDDL",
    "SIMP2_UCS_3838",
    "SIMP2_EMU2_EDDL",
    "STIMP_AVIONIC_3910",
    "STIMP_ATTACK_3910",
    "INTERFACE_TYPE_1",
    "INTERFACE_TYPE_2",
    "INTERFACE_TYPE_3",
    "INTERFACE_TYPE_4"
  };

  const TestEnum::value TestEnum::
  _xsd_TestEnum_indexes_[14] =
  {
    ::cs::TestEnum::INTERFACE_TYPE_1,
    ::cs::TestEnum::INTERFACE_TYPE_2,
    ::cs::TestEnum::INTERFACE_TYPE_3,
    ::cs::TestEnum::INTERFACE_TYPE_4,
    ::cs::TestEnum::SIMP1_AVIONIC_3910,
    ::cs::TestEnum::SIMP1_BSD_EDDL,
    ::cs::TestEnum::SIMP1_CSMU_EDDL,
    ::cs::TestEnum::SIMP1_MDP_EDDL,
    ::cs::TestEnum::SIMP2_ATTACK_3910,
    ::cs::TestEnum::SIMP2_EMU1_EDDL,
    ::cs::TestEnum::SIMP2_EMU2_EDDL,
    ::cs::TestEnum::SIMP2_UCS_3838,
    ::cs::TestEnum::STIMP_ATTACK_3910,
    ::cs::TestEnum::STIMP_AVIONIC_3910
  };

  // Channel
  //

  Channel::
  Channel (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_Channel_convert ();
  }

  Channel::
  Channel (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_Channel_convert ();
  }

  Channel::
  Channel (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_Channel_convert ();
  }

  Channel* Channel::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Channel (*this, f, c);
  }

  Channel::value Channel::
  _xsd_Channel_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_Channel_literals_);
    const value* i (::std::lower_bound (
                      _xsd_Channel_indexes_,
                      _xsd_Channel_indexes_ + 2,
                      *this,
                      c));

    if (i == _xsd_Channel_indexes_ + 2 || _xsd_Channel_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const Channel::
  _xsd_Channel_literals_[2] =
  {
    "CHANNEL_A",
    "CHANNEL_B"
  };

  const Channel::value Channel::
  _xsd_Channel_indexes_[2] =
  {
    ::cs::Channel::CHANNEL_A,
    ::cs::Channel::CHANNEL_B
  };

  // Type
  //

  Type::
  Type (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_Type_convert ();
  }

  Type::
  Type (const ::xercesc::DOMAttr& a,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_Type_convert ();
  }

  Type::
  Type (const ::std::string& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_Type_convert ();
  }

  Type* Type::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Type (*this, f, c);
  }

  Type::value Type::
  _xsd_Type_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_Type_literals_);
    const value* i (::std::lower_bound (
                      _xsd_Type_indexes_,
                      _xsd_Type_indexes_ + 5,
                      *this,
                      c));

    if (i == _xsd_Type_indexes_ + 5 || _xsd_Type_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const Type::
  _xsd_Type_literals_[5] =
  {
    "NONE",
    "3838",
    "3910",
    "ODDL",
    "EDDL"
  };

  const Type::value Type::
  _xsd_Type_indexes_[5] =
  {
    ::cs::Type::cxx_3838,
    ::cs::Type::cxx_3910,
    ::cs::Type::EDDL,
    ::cs::Type::NONE,
    ::cs::Type::ODDL
  };

  // InterfaceName
  //

  InterfaceName::
  InterfaceName (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_InterfaceName_convert ();
  }

  InterfaceName::
  InterfaceName (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_InterfaceName_convert ();
  }

  InterfaceName::
  InterfaceName (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_InterfaceName_convert ();
  }

  InterfaceName* InterfaceName::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class InterfaceName (*this, f, c);
  }

  InterfaceName::value InterfaceName::
  _xsd_InterfaceName_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_InterfaceName_literals_);
    const value* i (::std::lower_bound (
                      _xsd_InterfaceName_indexes_,
                      _xsd_InterfaceName_indexes_ + 12,
                      *this,
                      c));

    if (i == _xsd_InterfaceName_indexes_ + 12 || _xsd_InterfaceName_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const InterfaceName::
  _xsd_InterfaceName_literals_[12] =
  {
    "AVIONIC",
    "BSD",
    "MDP",
    "CSMU",
    "ATTACK",
    "EMU1",
    "EMU2",
    "UCS",
    "INTERFACE_1",
    "INTERFACE_2",
    "INTERFACE_3",
    "INTERFACE_4"
  };

  const InterfaceName::value InterfaceName::
  _xsd_InterfaceName_indexes_[12] =
  {
    ::cs::InterfaceName::ATTACK,
    ::cs::InterfaceName::AVIONIC,
    ::cs::InterfaceName::BSD,
    ::cs::InterfaceName::CSMU,
    ::cs::InterfaceName::EMU1,
    ::cs::InterfaceName::EMU2,
    ::cs::InterfaceName::INTERFACE_1,
    ::cs::InterfaceName::INTERFACE_2,
    ::cs::InterfaceName::INTERFACE_3,
    ::cs::InterfaceName::INTERFACE_4,
    ::cs::InterfaceName::MDP,
    ::cs::InterfaceName::UCS
  };

  // Read
  //

  Read::
  Read (const Address_type& Address)
  : ::xml_schema::type (),
    Address_ (Address, ::xml_schema::flags (), this),
    Alignment_ (::xml_schema::flags (), this)
  {
  }

  Read::
  Read (const Read& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Address_ (x.Address_, f, this),
    Alignment_ (x.Alignment_, f, this)
  {
  }

  Read::
  Read (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Address_ (f, this),
    Alignment_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void Read::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Address" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Address_type > r (
          Address_traits::create (i, f, this));

        this->Address_.set (r);
        continue;
      }

      if (n.name () == "Alignment" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Alignment_type > r (
          Alignment_traits::create (i, f, this));

        this->Alignment_.set (r);
        continue;
      }
    }

    if (!Address_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Address",
        "");
    }
  }

  Read* Read::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Read (*this, f, c);
  }

  Read::
  ~Read ()
  {
  }

  // Write
  //

  Write::
  Write (const Address_type& Address,
         const Data_type& Data)
  : ::xml_schema::type (),
    Address_ (Address, ::xml_schema::flags (), this),
    Data_ (Data, ::xml_schema::flags (), this),
    Alignment_ (::xml_schema::flags (), this)
  {
  }

  Write::
  Write (const Write& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Address_ (x.Address_, f, this),
    Data_ (x.Data_, f, this),
    Alignment_ (x.Alignment_, f, this)
  {
  }

  Write::
  Write (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Address_ (f, this),
    Data_ (f, this),
    Alignment_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void Write::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Address" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Address_type > r (
          Address_traits::create (i, f, this));

        this->Address_.set (r);
        continue;
      }

      if (n.name () == "Data" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Data_type > r (
          Data_traits::create (i, f, this));

        this->Data_.set (r);
        continue;
      }

      if (n.name () == "Alignment" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Alignment_type > r (
          Alignment_traits::create (i, f, this));

        this->Alignment_.set (r);
        continue;
      }
    }

    if (!Address_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Address",
        "");
    }

    if (!Data_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Data",
        "");
    }
  }

  Write* Write::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Write (*this, f, c);
  }

  Write::
  ~Write ()
  {
  }

  // SGA
  //

  SGA::
  SGA (const Value_type& Value)
  : ::xml_schema::type (),
    Value_ (Value, ::xml_schema::flags (), this)
  {
  }

  SGA::
  SGA (const SGA& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::type (x, f, c),
    Value_ (x.Value_, f, this)
  {
  }

  SGA::
  SGA (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
  : ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
    Value_ (f, this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, false, true);
      this->parse (p, f);
    }
  }

  void SGA::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    while (p.more_attributes ())
    {
      const ::xercesc::DOMAttr& i (p.next_attribute ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      if (n.name () == "Value" && n.namespace_ ().empty ())
      {
        ::std::auto_ptr< Value_type > r (
          Value_traits::create (i, f, this));

        this->Value_.set (r);
        continue;
      }
    }

    if (!Value_.present ())
    {
      throw ::xsd::cxx::tree::expected_attribute< char > (
        "Value",
        "");
    }
  }

  SGA* SGA::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class SGA (*this, f, c);
  }

  SGA::
  ~SGA ()
  {
  }

  // Board
  //

  Board::
  Board (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_Board_convert ();
  }

  Board::
  Board (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_Board_convert ();
  }

  Board::
  Board (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_Board_convert ();
  }

  Board* Board::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Board (*this, f, c);
  }

  Board::value Board::
  _xsd_Board_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_Board_literals_);
    const value* i (::std::lower_bound (
                      _xsd_Board_indexes_,
                      _xsd_Board_indexes_ + 4,
                      *this,
                      c));

    if (i == _xsd_Board_indexes_ + 4 || _xsd_Board_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const Board::
  _xsd_Board_literals_[4] =
  {
    "SIMP1",
    "SIMP2",
    "STIMP",
    "OTHER"
  };

  const Board::value Board::
  _xsd_Board_indexes_[4] =
  {
    ::cs::Board::OTHER,
    ::cs::Board::SIMP1,
    ::cs::Board::SIMP2,
    ::cs::Board::STIMP
  };

  // Command
  //

  Command::
  Command (const id_type& id,
           const Board_type& Board)
  : ::cs::CommandType (id,
                       Board)
  {
  }

  Command::
  Command (const Command& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::cs::CommandType (x, f, c)
  {
  }

  Command::
  Command (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
  : ::cs::CommandType (e, f, c)
  {
  }

  Command* Command::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Command (*this, f, c);
  }

  Command::
  ~Command ()
  {
  }

  // size
  //

  size::
  size (const ::xml_schema::integer& _xsd_integer_base)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (_xsd_integer_base)
  {
  }

  size::
  size (const size& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (x, f, c)
  {
  }

  size::
  size (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (e, f, c)
  {
  }

  size::
  size (const ::xercesc::DOMAttr& a,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (a, f, c)
  {
  }

  size::
  size (const ::std::string& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
  : ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (s, e, f, c)
  {
  }

  size* size::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class size (*this, f, c);
  }

  size::
  ~size ()
  {
  }

  // Alignment
  //

  Alignment::
  Alignment (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_Alignment_convert ();
  }

  Alignment::
  Alignment (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_Alignment_convert ();
  }

  Alignment::
  Alignment (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_Alignment_convert ();
  }

  Alignment* Alignment::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Alignment (*this, f, c);
  }

  Alignment::value Alignment::
  _xsd_Alignment_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_Alignment_literals_);
    const value* i (::std::lower_bound (
                      _xsd_Alignment_indexes_,
                      _xsd_Alignment_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_Alignment_indexes_ + 3 || _xsd_Alignment_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const Alignment::
  _xsd_Alignment_literals_[3] =
  {
    "B",
    "W",
    "D"
  };

  const Alignment::value Alignment::
  _xsd_Alignment_indexes_[3] =
  {
    ::cs::Alignment::B,
    ::cs::Alignment::D,
    ::cs::Alignment::W
  };

  // Alignment1
  //

  Alignment1::
  Alignment1 (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_Alignment1_convert ();
  }

  Alignment1::
  Alignment1 (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_Alignment1_convert ();
  }

  Alignment1::
  Alignment1 (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_Alignment1_convert ();
  }

  Alignment1* Alignment1::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Alignment1 (*this, f, c);
  }

  Alignment1::value Alignment1::
  _xsd_Alignment1_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_Alignment1_literals_);
    const value* i (::std::lower_bound (
                      _xsd_Alignment1_indexes_,
                      _xsd_Alignment1_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_Alignment1_indexes_ + 3 || _xsd_Alignment1_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const Alignment1::
  _xsd_Alignment1_literals_[3] =
  {
    "B",
    "W",
    "D"
  };

  const Alignment1::value Alignment1::
  _xsd_Alignment1_indexes_[3] =
  {
    ::cs::Alignment1::B,
    ::cs::Alignment1::D,
    ::cs::Alignment1::W
  };

  // Value
  //

  Value::
  Value (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (e, f, c)
  {
    _xsd_Value_convert ();
  }

  Value::
  Value (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (a, f, c)
  {
    _xsd_Value_convert ();
  }

  Value::
  Value (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
  : ::xml_schema::string (s, e, f, c)
  {
    _xsd_Value_convert ();
  }

  Value* Value::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class Value (*this, f, c);
  }

  Value::value Value::
  _xsd_Value_convert () const
  {
    ::xsd::cxx::tree::enum_comparator< char > c (_xsd_Value_literals_);
    const value* i (::std::lower_bound (
                      _xsd_Value_indexes_,
                      _xsd_Value_indexes_ + 3,
                      *this,
                      c));

    if (i == _xsd_Value_indexes_ + 3 || _xsd_Value_literals_[*i] != *this)
    {
      throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
    }

    return *i;
  }

  const char* const Value::
  _xsd_Value_literals_[3] =
  {
    "SGA_0",
    "SGA_1",
    "SGA_2"
  };

  const Value::value Value::
  _xsd_Value_indexes_[3] =
  {
    ::cs::Value::SGA_0,
    ::cs::Value::SGA_1,
    ::cs::Value::SGA_2
  };
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace cs
{
  ::std::auto_ptr< ::cs::CommandList >
  CommandList_ (const ::std::string& u,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::cs::CommandList > r (
      ::cs::CommandList_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::cs::CommandList >
  CommandList_ (const ::std::string& u,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::cs::CommandList > r (
      ::cs::CommandList_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::cs::CommandList >
  CommandList_ (const ::std::string& u,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        u, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::cs::CommandList > r (
      ::cs::CommandList_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::cs::CommandList >
  CommandList_ (::std::istream& is,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::cs::CommandList_ (isrc, f, p);
  }

  ::std::auto_ptr< ::cs::CommandList >
  CommandList_ (::std::istream& is,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::cs::CommandList_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::cs::CommandList >
  CommandList_ (::std::istream& is,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is);
    return ::cs::CommandList_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::cs::CommandList >
  CommandList_ (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::cs::CommandList_ (isrc, f, p);
  }

  ::std::auto_ptr< ::cs::CommandList >
  CommandList_ (::std::istream& is,
                const ::std::string& sid,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0,
      (f & ::xml_schema::flags::keep_dom) == 0);

    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::cs::CommandList_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::cs::CommandList >
  CommandList_ (::std::istream& is,
                const ::std::string& sid,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
    return ::cs::CommandList_ (isrc, h, f, p);
  }

  ::std::auto_ptr< ::cs::CommandList >
  CommandList_ (::xercesc::InputSource& i,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xsd::cxx::tree::error_handler< char > h;

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

    ::std::auto_ptr< ::cs::CommandList > r (
      ::cs::CommandList_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::cs::CommandList >
  CommandList_ (::xercesc::InputSource& i,
                ::xml_schema::error_handler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::cs::CommandList > r (
      ::cs::CommandList_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::cs::CommandList >
  CommandList_ (::xercesc::InputSource& i,
                ::xercesc::DOMErrorHandler& h,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::parse< char > (
        i, h, p, f));

    if (!d.get ())
      throw ::xsd::cxx::tree::parsing< char > ();

    ::std::auto_ptr< ::cs::CommandList > r (
      ::cs::CommandList_ (
        d, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  ::std::auto_ptr< ::cs::CommandList >
  CommandList_ (const ::xercesc::DOMDocument& d,
                ::xml_schema::flags f,
                const ::xml_schema::properties& p)
  {
    if (f & ::xml_schema::flags::keep_dom)
    {
      ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
        static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

      ::std::auto_ptr< ::cs::CommandList > r (
        ::cs::CommandList_ (
          c, f | ::xml_schema::flags::own_dom, p));

      return r;
    }

    const ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "CommandList" &&
        n.namespace_ () == "")
    {
      ::std::auto_ptr< ::cs::CommandList > r (
        ::xsd::cxx::tree::traits< ::cs::CommandList, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "CommandList",
      "");
  }

  ::std::auto_ptr< ::cs::CommandList >
  CommandList_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
                ::xml_schema::flags f,
                const ::xml_schema::properties&)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      ((f & ::xml_schema::flags::keep_dom) &&
       !(f & ::xml_schema::flags::own_dom))
      ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
      : 0);

    ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
    const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (f & ::xml_schema::flags::keep_dom)
      doc.setUserData (::xml_schema::dom::tree_node_key,
                       (c.get () ? &c : &d),
                       0);

    if (n.name () == "CommandList" &&
        n.namespace_ () == "")
    {
      ::std::auto_ptr< ::cs::CommandList > r (
        ::xsd::cxx::tree::traits< ::cs::CommandList, char >::create (
          e, f, 0));
      return r;
    }

    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "CommandList",
      "");
  }
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

namespace cs
{
  void
  CommandList_ (::std::ostream& o,
                const ::cs::CommandList& s,
                const ::xml_schema::namespace_infomap& m,
                const ::std::string& e,
                ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::cs::CommandList_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  CommandList_ (::std::ostream& o,
                const ::cs::CommandList& s,
                ::xml_schema::error_handler& h,
                const ::xml_schema::namespace_infomap& m,
                const ::std::string& e,
                ::xml_schema::flags f)
  {
    ::xsd::cxx::xml::auto_initializer i (
      (f & ::xml_schema::flags::dont_initialize) == 0);

    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::cs::CommandList_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  CommandList_ (::std::ostream& o,
                const ::cs::CommandList& s,
                ::xercesc::DOMErrorHandler& h,
                const ::xml_schema::namespace_infomap& m,
                const ::std::string& e,
                ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::cs::CommandList_ (s, m, f));
    ::xsd::cxx::xml::dom::ostream_format_target t (o);
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  CommandList_ (::xercesc::XMLFormatTarget& t,
                const ::cs::CommandList& s,
                const ::xml_schema::namespace_infomap& m,
                const ::std::string& e,
                ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::cs::CommandList_ (s, m, f));

    ::xsd::cxx::tree::error_handler< char > h;

    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
    }
  }

  void
  CommandList_ (::xercesc::XMLFormatTarget& t,
                const ::cs::CommandList& s,
                ::xml_schema::error_handler& h,
                const ::xml_schema::namespace_infomap& m,
                const ::std::string& e,
                ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::cs::CommandList_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  CommandList_ (::xercesc::XMLFormatTarget& t,
                const ::cs::CommandList& s,
                ::xercesc::DOMErrorHandler& h,
                const ::xml_schema::namespace_infomap& m,
                const ::std::string& e,
                ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::cs::CommandList_ (s, m, f));
    if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
    {
      throw ::xsd::cxx::tree::serialization< char > ();
    }
  }

  void
  CommandList_ (::xercesc::DOMDocument& d,
                const ::cs::CommandList& s,
                ::xml_schema::flags)
  {
    ::xercesc::DOMElement& e (*d.getDocumentElement ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (e));

    if (n.name () == "CommandList" &&
        n.namespace_ () == "")
    {
      e << s;
    }
    else
    {
      throw ::xsd::cxx::tree::unexpected_element < char > (
        n.name (),
        n.namespace_ (),
        "CommandList",
        "");
    }
  }

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
  CommandList_ (const ::cs::CommandList& s,
                const ::xml_schema::namespace_infomap& m,
                ::xml_schema::flags f)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      ::xsd::cxx::xml::dom::serialize< char > (
        "CommandList",
        "",
        m, f));

    ::cs::CommandList_ (*d, s, f);
    return d;
  }

  void
  operator<< (::xercesc::DOMElement& e, const TestType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // TestNumber
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "TestNumber",
          e));

      s << i.TestNumber ();
    }

    // TestString
    //
    if (i.TestString ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "TestString",
          e));

      s << *i.TestString ();
    }

    // Description
    //
    if (i.Description ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Description",
          e));

      s << *i.Description ();
    }

    // StepNumber
    //
    if (i.StepNumber ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "StepNumber",
          e));

      s << *i.StepNumber ();
    }

    // TestEnum
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "TestEnum",
          e));

      s << i.TestEnum ();
    }

    // TerminalNumber
    //
    if (i.TerminalNumber ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "TerminalNumber",
          e));

      s << *i.TerminalNumber ();
    }

    // Channel
    //
    if (i.Channel ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Channel",
          e));

      s << *i.Channel ();
    }

    // RCI
    //
    if (i.RCI ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "RCI",
          e));

      s << *i.RCI ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const BoardConfigurationType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // BaseAddress
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "BaseAddress",
          e));

      s << i.BaseAddress ();
    }

    // RAMsize
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "RAMsize",
          e));

      s << i.RAMsize ();
    }

    // Type
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Type",
          e));

      s << i.Type ();
    }

    // Arbitered_IO
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Arbitered_IO",
          e));

      s << i.Arbitered_IO ();
    }

    // Direct_IO
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Direct_IO",
          e));

      s << i.Direct_IO ();
    }

    // Restart_HS
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Restart_HS",
          e));

      s << i.Restart_HS ();
    }

    // InterfaceName
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "InterfaceName",
          e));

      s << i.InterfaceName ();
    }

    // RTAddress
    //
    if (i.RTAddress ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "RTAddress",
          e));

      s << *i.RTAddress ();
    }

    // BITHistory_Addr
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "BITHistory_Addr",
          e));

      s << i.BITHistory_Addr ();
    }

    // BITHistory_Size
    //
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "BITHistory_Size",
          e));

      s << i.BITHistory_Size ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const CommandType& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // Read
    //
    if (i.Read ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Read",
          e));

      s << *i.Read ();
    }

    // Write
    //
    if (i.Write ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Write",
          e));

      s << *i.Write ();
    }

    // Test
    //
    if (i.Test ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Test",
          e));

      s << *i.Test ();
    }

    // Config
    //
    if (i.Config ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Config",
          e));

      s << *i.Config ();
    }

    // SGA
    //
    if (i.SGA ())
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "SGA",
          e));

      s << *i.SGA ();
    }

    // id
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "id",
          e));

      a << i.id ();
    }

    // Board
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Board",
          e));

      a << i.Board ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const CommandList& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // Command
    //
    for (CommandList::Command_const_iterator
         b (i.Command ().begin ()), n (i.Command ().end ());
         b != n; ++b)
    {
      ::xercesc::DOMElement& s (
        ::xsd::cxx::xml::dom::create_element (
          "Command",
          e));

      s << *b;
    }

    // size
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "size",
          e));

      a << i.size ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const TestEnum& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const TestEnum& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const TestEnum& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const Channel& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const Channel& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const Channel& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const Type& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const Type& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const Type& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const InterfaceName& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const InterfaceName& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const InterfaceName& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const Read& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // Address
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Address",
          e));

      a << i.Address ();
    }

    // Alignment
    //
    if (i.Alignment ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Alignment",
          e));

      a << *i.Alignment ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Write& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // Address
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Address",
          e));

      a << i.Address ();
    }

    // Data
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Data",
          e));

      a << i.Data ();
    }

    // Alignment
    //
    if (i.Alignment ())
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Alignment",
          e));

      a << *i.Alignment ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const SGA& i)
  {
    e << static_cast< const ::xml_schema::type& > (i);

    // Value
    //
    {
      ::xercesc::DOMAttr& a (
        ::xsd::cxx::xml::dom::create_attribute (
          "Value",
          e));

      a << i.Value ();
    }
  }

  void
  operator<< (::xercesc::DOMElement& e, const Board& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const Board& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const Board& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const Command& i)
  {
    e << static_cast< const ::cs::CommandType& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const size& i)
  {
    e << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type >& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const size& i)
  {
    a << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type >& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const size& i)
  {
    l << static_cast< const ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type >& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const Alignment& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const Alignment& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const Alignment& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const Alignment1& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const Alignment1& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const Alignment1& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMElement& e, const Value& i)
  {
    e << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xercesc::DOMAttr& a, const Value& i)
  {
    a << static_cast< const ::xml_schema::string& > (i);
  }

  void
  operator<< (::xml_schema::list_stream& l,
              const Value& i)
  {
    l << static_cast< const ::xml_schema::string& > (i);
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

